-- +goose Up
-- SQL in section 'Up' is executed when this migration is applied

-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
10,
2,
'Given:
<code>public abstract interface Frobnicate { public void twiddle(String s); }</code>

Which is a correct class? (Choose all that apply.)',
'✔ <b>B</b> is correct, an abstract class need not implement any or all of an interface''s methods. <b>E</b> is correct, the class implements the interface method and additionally overloads the <code>twiddle()</code> method.
❌ <b>A</b> is incorrect because abstract methods have no body. <b>C</b> is incorrect because classes implement interfaces they don’t extend them. <b>D</b> is incorrect because overloading a method is not implementing it.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(10, 'A',
'<code>public abstract class Frob implements Frobnicate {
    public abstract void twiddle(String s) { }
  }</code>', 0),
(10, 'B','<code>public abstract class Frob implements Frobnicate { }</code>', 1),
(10, 'C',
'<code>public class Frob extends Frobnicate {
    public void twiddle(Integer i) { }
  }</code>', 0),
(10, 'D',
'<code>public class Frob implements Frobnicate {
    public void twiddle(Integer i) { }
  }</code>', 0),
(10, 'E',
'<code>public class Frob implements Frobnicate {
    public void twiddle(String i) { }
    public void twiddle(Integer s) { }
  }</code>', 1);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
11,
2,
'Given:
<code>class Top {
  public Top(String s) { System.out.print("B"); }
}
public class Bottom2 extends Top {
  public Bottom2(String s) { System.out.print("D"); }
  public static void main(String [] args) {
    new Bottom2("C");
    System.out.println(" ");
} }</code>

What is the result?',
'✔ <b>E</b> is correct. The implied <code>super()</code> call in Bottom2’s constructor cannot be satisfied because there isn''t a no-arg constructor in Top. A default, no-arg constructor is generated by the compiler only if the class has no constructor defined explicitly.
❌ <b>A, B, C,</b> and <b>D</b> are incorrect based on the above.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(11, 'A','<code>BD</code>', 0),
(11, 'B','<code>DB</code>', 0),
(11, 'C','<code>BDC</code>', 0),
(11, 'D','<code>DBC</code>', 0),
(11, 'E','Compilation fails', 1);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
12,
2,
'Given:
<code>class Clidder {
  private final void flipper() { System.out.println("Clidder"); }
}
public class Clidlet extends Clidder {
  public final void flipper() { System.out.println("Clidlet"); }
  public static void main(String [] args) {
    new Clidlet().flipper();
} }</code>

What is the result?',
'✔ <b>A</b> is correct. Although a final method cannot be overridden, in this case, the method is private, and therefore hidden. The effect is that a new, accessible, method flipper is created. Therefore, no polymorphism occurs in this example, the method invoked is simply that of the child class, and no error occurs.
❌ <b>B, C, D,</b> and <b>E</b> are incorrect based on the preceding.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(12, 'A','<code>Clidlet</code>', 1),
(12, 'B','<code>Clidder</code>', 0),
(12, 'C',
'<code>Clidder
Clidlet</code>', 0),
(12, 'D',
'<code>Clidlet
Clidder</code>', 0),
(12, 'E','Compilation fails', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
13,
2,
'Which statement(s) are true? (Choose all that apply.)',
'✔ Answer <b>C</b> is correct.
❌ <b>A</b> refers to encapsulation, <b>B</b> refers to coupling, and <b>D</b> refers to polymorphism.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(13, 'A','Cohesion is the OO principle most closely associated with hiding implementation details', 0),
(13, 'B','Cohesion is the OO principle most closely associated with making sure that classes know about other classes only through their APIs', 0),
(13, 'C','Cohesion is the OO principle most closely associated with making sure that a class is designed with a single, well-focused purpose', 1),
(13, 'D','Cohesion is the OO principle most closely associated with allowing a single object to be seen as having many types', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
14,
2,
'Given:
<code> 1. class X { void do1() { } }
 2. class Y extends X { void do2() { } }
 3.
 4. class Chrome {
 5.   public static void main(String [] args) {
 6.     X x1 = new X();
 7.     X x2 = new Y();
 8.     Y y1 = new Y();
 9.     // insert code here
10.   }
11. }</code>

Which, inserted at line 9, will compile? (Choose all that apply.)',
'✔ <b>C</b> is correct. Before you can invoke Y''s do2 method you have to cast x2 to be of type Y. Statement <b>B</b> looks like a proper cast but without the second set of parentheses, the compiler thinks it''s an incomplete statement.
❌ <b>A, B</b> and <b>D</b> are incorrect based on the preceding.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(14, 'A','<code>x2.do2();</code>', 0),
(14, 'B','<code>(Y)x2.do2();</code>', 0),
(14, 'C','<code>((Y)x2).do2();</code>', 1),
(14, 'D','None of the above statements will compile', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
15,
2,
'Given:
 1. ClassA has a ClassD
 2. Methods in ClassA use public methods in ClassB
 3. Methods in ClassC use public methods in ClassA
 4. Methods in ClassA use public variables in ClassB

Which is most likely true? (Choose the most likely.)',
'✔ <b>C</b> is correct. Generally speaking, public variables are a sign of weak encapsulation.
❌ <b>A, B, D,</b> and <b>E</b> are incorrect, because based on the information given, none of these statements can be supported.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(15, 'A', 'ClassD has low cohesion', 0),
(15, 'B', 'ClassA has weak encapsulation', 0),
(15, 'C', 'ClassB has weak encapsulation', 1),
(15, 'D', 'ClassB has strong encapsulation', 0),
(15, 'E', 'ClassC is tightly coupled to ClassA', 0);



-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
16,
2,
'Given:
<code> 3. class Dog {
 4.   public void bark() { System.out.print("woof "); }
 5. }
 6. class Hound extends Dog {
 7.   public void sniff() { System.out.print("sniff "); }
 8.   public void bark() { System.out.print("howl "); }
 9. }
10. public class DogShow {
11.   public static void main(String[] args) { new DogShow().go(); }
12.   void go() {
13.     new Hound().bark();
14.     ((Dog) new Hound()).bark();
15.     ((Dog) new Hound()).sniff();
16.   }
17. }
</code>

What is the result? (Choose all that apply.)',
'✔ <b>F</b> is correct. Class Dog doesn''t have a sniff method.
❌ <b>A, B, C, D,</b> and <b>E</b> are incorrect based on the above information.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(16, 'A','<code>howl howl sniff</code>', 0),
(16, 'B','<code>howl woof sniff</code>', 0),
(16, 'C','<code>howl howl</code> followed by an exception', 0),
(16, 'D','<code>howl woof</code> followed by an exception', 0),
(16, 'E','Compilation fails with an error at line 14', 0),
(16, 'F','Compilation fails with an error on line 15', 1);



-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
17,
2,
'Given:
<code> 3. public class Redwood extends Tree {
 4.   public static void main(String[] args) {
 5.     new Redwood().go();
 6.   }
 7.   void go() {
 8.     go2(new Tree(), new Redwood());
 9.     go2((Redwood) new Tree(), new Redwood());
10.   }
11.   void go2(Tree t1, Redwood r1) {
12.     Redwood r2 = (Redwood)t1;
13.     Tree t2 = (Tree)r1;
14.   }
15. }
16. class Tree { }</code>

What is the result? (Choose all that apply.)',
'✔ <b>A</b> is correct, a ClassCastException will be thrown when the code attempts to downcast a Tree to a Redwood.
❌ <b>B, C, D, E,</b> and <b>F</b> are incorrect based on the above information.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(17, 'A','An exception is thrown at runtime', 1),
(17, 'B','The code compiles and runs with no output', 0),
(17, 'C','Compilation fails with an error on line 8', 0),
(17, 'D','Compilation fails with an error on line 9', 0),
(17, 'E','Compilation fails with an error on line 12', 0),
(17, 'F','Compilation fails with an error on line 13', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
18,
2,
'Given:
<code> 3. public class Tenor extends Singer {
 4.   public static String sing() { return "fa"; }
 5.   public static void main(String[] args) {
 6.     Tenor t = new Tenor();
 7.     Singer s = new Tenor();
 8.     System.out.println(t.sing() + " " + s.sing());
 9.   }
10. }
11. class Singer { public static String sing() { return "la"; } }</code>

What is the result?',
'✔ <b>B</b> is correct. The code is correct, but polymorphism doesn''t apply to static methods.
❌ <b>A, C, D,</b> and <b>E</b> are incorrect based on the above information.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(18, 'A','<code>fa fa</code>', 0),
(18, 'B','<code>fa la</code>', 1),
(18, 'C','<code>la la</code>', 0),
(18, 'D','Compilation fails', 0),
(18, 'E','An exception is thrown at runtime', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
19,
2,
'Given:
<code>3. class Alpha {
 4.   static String s = " ";
 5.   protected Alpha() { s += "alpha "; }
 6. }
 7. class SubAlpha extends Alpha {
 8.   private SubAlpha() { s += "sub "; }
 9. }
10. public class SubSubAlpha extends Alpha {
11.   private SubSubAlpha() { s += "subsub "; }
12.   public static void main(String[] args) {
13.     new SubSubAlpha();
14.     System.out.println(s);
15.   }
16. }</code>

What is the result?',
'✔ <b>C</b> is correct. Watch out, <code>SubSubAlpha</code> extends <code>Alpha</code>! Since the code doesn''t attempt to make a <code>SubAlpha</code>, the private constructor in <code>SubAlpha</code> is okay.
❌ <b>A, B, D, E,</b> and <b>F</b> are incorrect based on the above information.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(19, 'A','<code>subsub</code>', 0),
(19, 'B','<code>sub subsub</code>', 0),
(19, 'C','<code>alpha subsub</code>', 1),
(19, 'D','<code>alpha sub subsub</code>', 0),
(19, 'E','Compilation fails', 0),
(19, 'F','An exception is thrown at runtime', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
20,
2,
'Given:
<code> 3. class Building {
 4.   Building() { System.out.print("b "); }
 5.   Building(String name) {
 6.     this(); System.out.print("bn " + name);
 7.   }
 8. }
 9. public class House extends Building {
10.   House() { System.out.print("h "); }
11.   House(String name) {
12.     this(); System.out.print("hn " + name);
13.   }
14.   public static void main(String[] args) { new House("x "); }
15. }</code>

What is the result?',
'✔ <b>C</b> is correct. Remember that constructors call their superclass constructors, which execute first, and that constructors can be overloaded.
❌ <b>A, B, D, E, F, G,</b> and <b>H</b> are incorrect based on the above information.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(20, 'A','<code>h hn x</code>', 0),
(20, 'B','<code>hn x h</code>', 0),
(20, 'C','<code>b h hn x</code>', 1),
(20, 'D','<code>b hn x h</code>', 0),
(20, 'E','<code>bn x h hn x</code>', 0),
(20, 'F','<code>b bn x h hn x</code>', 0),
(20, 'G','<code>bn x b h hn x</code>', 0),
(20, 'H','Compilation fails', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
21,
2,
'Given:
<code> 3. class Mammal {
 4.   String name = "furry ";
 5.   String makeNoise() { return "generic noise"; }
 6. }
 7. class Zebra extends Mammal {
 8.   String name = "stripes ";
 9.   String makeNoise() { return "bray"; }
10. }
11. public class ZooKeeper {
12.   public static void main(String[] args) { new ZooKeeper().go(); }
13.   void go() {
14.     Mammal m = new Zebra();
15.     System.out.println(m.name + m.makeNoise());
16.   }
17. }</code>

What is the result?',
'✔ <b>A</b> is correct. Polymorphism is only for instance methods.
❌ <b>B, C, D, E,</b> and <b>F</b> are incorrect based on the above information.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(21, 'A','<code>furry bray</code>', 1),
(21, 'B','<code>stripes bray</code>', 0),
(21, 'C','<code>furry generic noise</code>', 0),
(21, 'D','<code>stripes generic noise</code>', 0),
(21, 'E','Compilation fails', 0),
(21, 'F','An exception is thrown at runtime', 0);


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
22,
2,
'You’re designing a new online board game in which Floozels are a type of Jammers, Jammers can have Quizels, Quizels are a type of Klakker, and Floozels can have several Floozets. Which of the following fragments represent this design? (Choose all that apply.)',
'✔ <b>A</b> and <b>C</b> are correct. The phrase "type of" indicates an "is-a" relationship (extends or implements), and the phrase “have” is of course a "has-a" relationship (usually instance variables).
❌ <b>B</b> and <b>D</b> are incorrect based on the above information.');
-- +goose StatementEnd

-- +goose StatementBegin
INSERT INTO answer (question_id, letter, answer, valid) VALUES
(22, 'A',
'<code>import java.util.*;
interface Klakker { }
class Jammer { Set&lt;Quizel&gt; q; }
class Quizel implements Klakker { }
public class Floozel extends Jammer { List&lt;Floozet&gt; f; }
interface Floozet { }</code>', 1),
(22, 'B',
'<code>import java.util.*;
class Klakker { Set&lt;Quizel&gt; q; }
class Quizel extends Klakker { }
class Jammer { List&lt;Floozel&gt; f; }
class Floozet extends Floozel { }
public class Floozel { Set&lt;Klakker&gt; k; }</code>', 0),
(22, 'C',
'<code>import java.util.*;
class Floozet { }
class Quizel implements Klakker { }
class Jammer { List&lt;Quizel&gt; q; }
interface Klakker { }
class Floozel extends Jammer { List&lt;Floozet&gt; f; }</code>', 1),
(22, 'D',
'<code>import java.util.*;
interface Jammer extends Quizel { }
interface Klakker { }
interface Quizel extends Klakker { }
interface Floozel extends Jammer, Floozet { }
interface Floozet { }</code>', 0);
-- +goose StatementEnd


-- +goose StatementBegin
INSERT INTO question (id, chapter_id, text, explanation) VALUES (
23,
2,
'Given:
<code> 3. class A { }
 4. class B extends A { }
 5. public class ComingThru {
 6.   static String s = "-";
 7.   public static void main(String[] args) {
 8.     A[] aa = new A[2];
 9.     B[] ba = new B[2];
10.     sifter(aa);
11.     sifter(ba);
12.     sifter(7);
13.     System.out.println(s);
14.   }
15.   static void sifter(A[]... a2) { s += "1"; }
16.   static void sifter(B[]... b1) { s += "2"; }
17.   static void sifter(B[] b1) { s += "3"; }
18.   static void sifter(Object o) { s += "4"; }
19.   }</code>

What is the result?',
'✔ <b>D</b> is correct. In general, overloaded var-args methods are chosen last. Remember that arrays are objects. Finally, an int can be boxed to an Integer and then "widened" to an Object.
❌ <b>A, B, C, E,</b> and <b>F</b> are incorrect based on the above information.');
-- +goose StatementEnd

INSERT INTO answer (question_id, letter, answer, valid) VALUES
(23, 'A','<code>-124</code>', 0),
(23, 'B','<code>-134</code>', 0),
(23, 'C','<code>-424</code>', 0),
(23, 'D','<code>-434</code>', 1),
(23, 'E','<code>-444</code>', 0),
(23, 'F','Compilation fails', 0);

-- +goose Down
-- SQL section 'Down' is executed when this migration is rolled back


